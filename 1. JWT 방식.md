# JWT 방식
> [JWT에 관한 설명](https://github.com/OOOIOOOIO/Study-Web-Development/blob/master/Web%20basic/JWT(Json%20Web%20Token).md)
> 
<hr>
<br>

# package 구조

![image](https://user-images.githubusercontent.com/74396651/204975725-79c63c39-97c2-4ba0-b9e9-4c03b9159b44.png)

<hr>

# build.graddle(jwt 설정)
```java
// jwt
implementation 'io.jsonwebtoken:jjwt-api:0.11.2'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.2'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.2'
```

<hr>

# application.properties

![image](https://user-images.githubusercontent.com/74396651/204975777-e143532f-83e5-470f-acd5-476fdfee5f5a.png)

<hr>

# config
```java
package com.sh.loginpratice.commonjwt.config.jwt;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.Map;

/**
 * application.properties에 선언된 속성들을 사용하며
 * 토큰을 만드는 부분
 * 토큰의 검증 및 내용 확인 부분으로 구성된다.
 *
 */
@Slf4j
@Component
public class JwtUtil {
    // application.properties 에 사용된 값 주입, 비밀번호에 덧붙이는 값, signature에서 사용
    @Value("${jwt.salt}")
    private String salt;

    @Value("${jwt.expireMin}")
    private Long expireMin;

    /**
     * 토큰 생성
     * @param email
     * @return
     */
    public String createAuthToken(String email) {
        return create(email, "authToken", expireMin);
    }

    /**
     * 로그인 성공 시 사용자 정보를 기반으로 JWTToken을 생성하여 반환한다.
     * @param email
     * @param subject
     * @param expireMin
     * @return
     */
    public String create(String email, String subject, long expireMin) {
        // 토큰 생성
        final JwtBuilder builder = Jwts.builder();

        // Header 설정
        builder.setHeaderParam("typ", "JWT");
        builder.setHeaderParam("alg", "HS256");

        // Payload 설정
        builder.setSubject(subject) // 제목 설정 1000 * 60 * 2 == (1000(1초) * 60(1분)) * 2 => 2분 
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * expireMin)); // 유효기간 설정, expireMin = 2

        // 담고 싶은 정보 설정
        if (email != null) {
            builder.claim("user", email);
        }

        // signature 설정, 암호화
//        builder.signWith(SignatureAlgorithm.HS256, salt.getBytes());
        Key key = Keys.hmacShaKeyFor("qwertyuiopasdfghjklzxcvbnmqwerty".getBytes());
        builder.signWith(key, SignatureAlgorithm.HS256);

        // 직렬화 처리로 마무리
        final String jwt = builder.compact();
        log.info("토큰 발행 : {}", jwt);

        return jwt;
    }

    /**
     * JWT 토큰을 분석해서 필요한 정보를 반환한다.
     * 토큰에 문제가 있다면 Runtime Exception을 던진다.
     * @param jwt
     * @return
     */
    public Map<String, Object> checkAndGetClaims(String jwt) {
//        Jws<Claims> claims = Jwts.parser()
//                .setSigningKey(salt.getBytes())
//                .parseClaimsJws(jwt);

        Jws<Claims> claims = Jwts.parserBuilder()
                .setSigningKey(salt.getBytes())
                .build()
                .parseClaimsJws(jwt);

        log.trace("claims : {}", claims);

        return claims.getBody();
    }

}

```

<hr>

# Test Code
```java
package com.sh.loginpratice.commonjwt.jwtTest;

import com.sh.loginpratice.commonjwt.config.jwt.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.MalformedJwtException;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.Map;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
public class TokenTest {
    @Autowired
    JwtUtil jwtUtil;

    @Test
    public void tokenGenerateTest() throws Exception{
        //given
        String email = "polite159@gmail.com";
        //when
        String token = jwtUtil.createAuthToken(email);
        //then
        assertNotNull(token);
        System.out.println(token);
        /*
        1차
        eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhdXRoVG9rZW4iLCJleHAiOjE2Njk4NzEyNjAsInVzZXIiOiJwb2xpdGUxNTlAZ21haWwuY29tIn0.uZjOYQaMOudpMLahVvb2kpsuoTri3v6-Nxr3ifXmk-E

        2차
        eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhdXRoVG9rZW4iLCJleHAiOjE2Njk4NzE0MTksInVzZXIiOiJwb2xpdGUxNTlAZ21haWwuY29tIn0.LQbo8VHInuOSjvZC0b8Vtw0cddY4zMueEqj-OugqXac

        확인 => header, payload는 같지만 signature는 바뀐다.
         */
    }

    @Test
    public void checkTokenTest() throws Exception{
        //given
        String email = "polite159@gmail.com";
        //when
        String token = jwtUtil.createAuthToken(email);
        Map<String, Object> payload = jwtUtil.checkAndGetClaims(token);

        //then
        assertEquals(payload.get("sub"), "authToken");
        assertEquals(payload.get("user"), email);
    }

    /**
     * 잘못된 토큰 정보를 넘겼을 경우 MalformedJwtException 발생!
     * @throws Exception
     */
    @Test
    public void wrongTokenTest() throws Exception{
        //given
        String fakeToken = "fakeToken";
        //when-then
        assertThrows(MalformedJwtException.class, () -> jwtUtil.checkAndGetClaims(fakeToken));
    }

    /**
     * 형식은 적합하지만 유효기간이 지난 토큰을 사용할 경우 ExpiredJwtException 발생!
     * 이는 이후 RefreshToken을 생성하는 근거가 된다.
     * @throws Exception
     */
    @Test
    public void expiredTest() throws Exception{
        //given
        String fakeToken = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhdXRoVG9rZW4iLCJleHAiOjE2Njk4NzEyNjAsInVzZXIiOiJwb2xpdGUxNTlAZ21haWwuY29tIn0.uZjOYQaMOudpMLahVvb2kpsuoTri3v6-Nxr3ifXmk-E";
        //when-then
        assertThrows(ExpiredJwtException.class, () -> jwtUtil.checkAndGetClaims(fakeToken));
    }
}

```

<hr>

# 발행한 토큰 파싱해보기!

![image](https://user-images.githubusercontent.com/74396651/204976334-2ba604b5-93e8-4a54-b746-5a3f1af114ea.png)

